def prox_rank1_generic(prox, prox_brk_pts, x0, d, u = None, lamda = None, linTerm = None, plusminus=1, invert = True):
	
	if (len(u) == 0):
		u = np.asarray([[0]])
		
	if (np.all(u == 0)):
		NO_U = True
	else:
		NO_U = False

	if (NO_U):
		uinv = 0
	else:
		uinv = u / d / np.sqrt(1.0 + u.T.dot(u/d))
			
		
	if (invert):
		Vinv = lambda y : d / y + plusminus * (u.T.dot(y)).dot(u)
		dd = 1.0 / d
		uu = uinv
		plusminus = -plusminus
		
		if (NO_U):
			ud = u / np.sqrt(1.0+u*(u/d))
		else:
			ud = u / np.sqrt(1.0+u.T.dot(u/d))
		dInv = 1.0 / dd
		
	else:
		Vinv = lambda y : y / d - plusminus * (uinv.T.dot(y)).dot(uinv)
		dd = d.copy()
		uu = u.copy()
		
		ud = uu / dd
		dInv = 1.0 / dd

	if (NO_U):
		uu = 0
		ud = 0
	
	if (np.any(lamda) == 0):
		print "scaling factor lambda must be non-zero"
	x0 *= lamda
		
	dd /= lamda**2
	uu /= lamda
	ud *= lamda
	dInv = 1.0 / dd
	
	t = prox_brk_pts(1.0 / dd)
	
	X = lambda a : prox(x0 - plusminus * a * ud, dInv)
	
	if (NO_U):		
		x = prox(x0, dInv)
		x /= lamda
		return x
	
	brk_pts = plusminus * (dd/uu) * (x0-t)
	brk_pts = np.unique(brk_pts)
	brk_pts = brk_pts[np.where(np.isfinite(brk_pts))]
	
	lwrBnd = 0
	uprBnd = len(brk_pts)
	iMax = int(np.ceil(np.log2(len(brk_pts))) + 1)
	for i in range(iMax):
		if (uprBnd - lwrBnd <= 1):
			#print "Bounds are too close"
			break
		j = int(round(np.mean([lwrBnd,uprBnd])))
		#print "j is {0} (bounds were [{1},{2}])".format(j,lwrBnd,uprBnd)
		
		if (j == lwrBnd):
			j += 1
		elif (j == uprBnd):
			j -= 1
		
		a = brk_pts[j]
		x = X(a)
		
		p = a + uu.T.dot(x0-x)
		
		if (p > 0):
			uprBnd = j
		elif (p < 0):
			lwrBnd = j
			
		
	cnt = i  # Number of iterations
	
	if (lwrBnd == 0):
		a2 = brk_pts[uprBnd]
		a1 = a2 - 10     # Arbitrary
		aBounds = np.asarray([-np.inf, a2])
	elif (uprBnd == len(brk_pts)):
		a1 = brk_pts[lwrBnd]
		a2 = a1 + 10     # Arbitrary
		aBounds = np.asarray([a1,np.inf])
	else:
		a1 = brk_pts[lwrBnd]
		a2 = brk_pts[uprBnd]
		aBounds = np.asarray([a1, a2])
		
	x1 = X(a1)
	x2 = X(a2)
	dx = (x2-x1) / (a2-a1)
	
	a = uu.T.dot(x0 - x1 + a1 * dx) / (-1.0 + uu.T.dot(dx))
	
	if ((a < aBounds[0]) | (a > aBounds[1])):
		print "alpha is not the correct range"
		
# The solution
	x = X(a)
	
	x /= lamda
	
	
	return x